import {
  require_mousetrap
} from "./chunk-PWAPWRBG.js";
import {
  __toESM
} from "./chunk-TCQZMY3T.js";

// node_modules/svelte-focus-trap/src/index.js
var import_mousetrap = __toESM(require_mousetrap());

// node_modules/svelte-focus-trap/src/utils.js
function runInSeries(tasks) {
  return (...initialArgs) => {
    return tasks.reduce((memo, task) => memo = [...[task(...memo)]], initialArgs || []);
  };
}
function elementIsVisible(element) {
  let computedStyle = document.defaultView.getComputedStyle(element, null);
  return computedStyle.getPropertyValue("display") !== "none" && computedStyle.getPropertyValue("visibility") !== "hidden";
}
var FOCUSABLE_ELEMENTS = [
  "a[href]",
  "area[href]",
  'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
  "select:not([disabled]):not([aria-hidden])",
  "textarea:not([disabled]):not([aria-hidden])",
  "button:not([disabled]):not([aria-hidden])",
  "iframe",
  "object",
  "embed",
  "[contenteditable]",
  '[tabindex]:not([tabindex^="-"])'
];

// node_modules/svelte-focus-trap/src/index.js
function focusTrap(node) {
  const keyboardShortcuts = {
    "alt+tab": previous,
    "end": focusLastItem,
    "home": focusFirstItem,
    "shift+tab": previous,
    down: next,
    tab: next,
    up: previous
  };
  Object.entries(keyboardShortcuts).forEach(([keys, handler]) => {
    import_mousetrap.default.bind(keys, runInSeries([
      (event) => ({ event }),
      preventDefault,
      stopPropagation,
      getAllFocusableChildren,
      getCurrentlyFocusedItem,
      handler
    ]));
  });
  function preventDefault(context) {
    context.event.preventDefault();
    return context;
  }
  function stopPropagation(context) {
    context.event.stopPropagation();
    return context;
  }
  function getAllFocusableChildren(context) {
    let focusables = [...node.querySelectorAll(FOCUSABLE_ELEMENTS)];
    return {
      ...context,
      allFocusableItems: focusables.filter(elementIsVisible)
    };
  }
  function getCurrentlyFocusedItem(context) {
    let currentlyFocusedItem = document.activeElement;
    if (currentlyFocusedItem && !node.contains(currentlyFocusedItem)) {
      return context;
    }
    return {
      ...context,
      currentlyFocusedItem
    };
  }
  function next({ allFocusableItems, currentlyFocusedItem }) {
    if (!currentlyFocusedItem) {
      allFocusableItems[0] && allFocusableItems[0].focus();
      return;
    }
    let currentlyFocusedIndex = allFocusableItems.indexOf(currentlyFocusedItem);
    if (allFocusableItems.length - 1 === currentlyFocusedIndex) {
      allFocusableItems[0] && allFocusableItems[0].focus();
      return;
    }
    allFocusableItems[currentlyFocusedIndex + 1] && allFocusableItems[currentlyFocusedIndex + 1].focus();
  }
  function previous({ allFocusableItems, currentlyFocusedItem }) {
    if (!currentlyFocusedItem) {
      allFocusableItems[allFocusableItems.length - 1].focus();
      return;
    }
    let currentlyFocusedIndex = allFocusableItems.indexOf(currentlyFocusedItem);
    if (currentlyFocusedIndex === 0) {
      allFocusableItems[allFocusableItems.length - 1] && allFocusableItems[allFocusableItems.length - 1].focus();
      return;
    }
    allFocusableItems[currentlyFocusedIndex - 1] && allFocusableItems[currentlyFocusedIndex - 1].focus();
  }
  function focusFirstItem({ allFocusableItems }) {
    allFocusableItems[0] && allFocusableItems[0].focus();
  }
  function focusLastItem({ allFocusableItems }) {
    allFocusableItems[allFocusableItems.length - 1].focus();
  }
  return {
    destroy() {
      Object.keys(keyboardShortcuts).forEach((key) => import_mousetrap.default.unbind(key));
    }
  };
}
export {
  focusTrap
};
//# sourceMappingURL=svelte-focus-trap.js.map
