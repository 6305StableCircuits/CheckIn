import {
  ColumnSizing,
  Expanding,
  Filters,
  Grouping,
  Headers,
  Ordering,
  Pagination,
  Pinning,
  RowSelection,
  Sorting,
  Visibility,
  aggregationFns,
  buildHeaderGroups,
  createCell,
  createColumn,
  createColumnHelper,
  createRow,
  createTable,
  defaultColumnSizing,
  expandRows,
  filterFns,
  flattenBy,
  functionalUpdate,
  getCoreRowModel,
  getExpandedRowModel,
  getFacetedMinMaxValues,
  getFacetedRowModel,
  getFacetedUniqueValues,
  getFilteredRowModel,
  getGroupedRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  isFunction,
  isNumberArray,
  isRowSelected,
  isSubRowSelected,
  makeStateUpdater,
  memo,
  noop as noop2,
  orderColumns,
  passiveEventSupported,
  reSplitAlphaNumeric,
  selectRowsFn,
  shouldAutoRemoveFilter,
  sortingFns
} from "./chunk-T6IDCRFL.js";
import {
  derived,
  readable,
  writable
} from "./chunk-3FMCWP3K.js";
import {
  SvelteComponent,
  claim_component,
  claim_text,
  create_component,
  create_ssr_component,
  destroy_component,
  detach,
  escape,
  get_store_value,
  init,
  insert_hydration,
  mount_component,
  noop,
  safe_not_equal,
  set_data,
  text,
  transition_in,
  transition_out,
  validate_component
} from "./chunk-4QQQ57VX.js";
import "./chunk-LYBY5SRM.js";
import "./chunk-TCQZMY3T.js";

// node_modules/@tanstack/svelte-table/build/lib/index.mjs
function create_fragment$1(ctx) {
  let t;
  return {
    c() {
      t = text(
        /*content*/
        ctx[0]
      );
    },
    l(nodes) {
      t = claim_text(
        nodes,
        /*content*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*content*/
      1)
        set_data(
          t,
          /*content*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { content } = $$props;
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
  };
  return [content];
}
var Placeholder$1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment$1, safe_not_equal, { content: 0 });
  }
};
var PlaceholderServer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${escape($$props.content)}`;
});
var Placeholder = typeof document === "undefined" ? PlaceholderServer : Placeholder$1;
function create_fragment(ctx, Comp, props) {
  let c;
  let current;
  c = new Comp({
    props,
    $$inline: true
  });
  return {
    c() {
      create_component(c.$$.fragment);
    },
    l(nodes) {
      claim_component(c.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(c, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(c.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(c.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(c, detaching);
    }
  };
}
function renderClient(Comp, props) {
  return class WrapperComp extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, (ctx) => create_fragment(ctx, Comp, props), safe_not_equal, {}, void 0);
    }
  };
}
function renderServer(Comp, props) {
  const WrapperComp = create_ssr_component(($$result, $$props, $$bindings, slots) => {
    return `${validate_component(Comp, "TableComponent").$$render($$result, props, {}, {})}`;
  });
  return WrapperComp;
}
var renderComponent = typeof window === "undefined" ? renderServer : renderClient;
function isSvelteServerComponent(component) {
  return typeof component === "object" && typeof component.$$render === "function" && typeof component.render === "function";
}
function isSvelteClientComponent(component) {
  var _component$name, _component$name2;
  let isHMR = "__SVELTE_HMR" in window;
  return component.prototype instanceof SvelteComponent || isHMR && ((_component$name = component.name) == null ? void 0 : _component$name.startsWith("Proxy<")) && ((_component$name2 = component.name) == null ? void 0 : _component$name2.endsWith(">"));
}
function isSvelteComponent(component) {
  if (typeof document === "undefined") {
    return isSvelteServerComponent(component);
  } else {
    return isSvelteClientComponent(component);
  }
}
function wrapInPlaceholder(content) {
  return renderComponent(Placeholder, {
    content
  });
}
function flexRender(component, props) {
  if (!component)
    return null;
  if (isSvelteComponent(component)) {
    return renderComponent(component, props);
  }
  if (typeof component === "function") {
    const result = component(props);
    if (result === null || result === void 0)
      return null;
    if (isSvelteComponent(result)) {
      return renderComponent(result, props);
    }
    return wrapInPlaceholder(result);
  }
  return wrapInPlaceholder(component);
}
function createSvelteTable(options) {
  let optionsStore;
  if ("subscribe" in options) {
    optionsStore = options;
  } else {
    optionsStore = readable(options);
  }
  let resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...get_store_value(optionsStore)
  };
  let table = createTable(resolvedOptions);
  let stateStore = writable(
    /** @type {number} */
    table.initialState
  );
  let stateOptionsStore = derived([stateStore, optionsStore], (s) => s);
  const tableReadable = readable(table, function start(set) {
    const unsubscribe = stateOptionsStore.subscribe((_ref) => {
      let [state, options2] = _ref;
      table.setOptions((prev) => {
        return {
          ...prev,
          ...options2,
          state: {
            ...state,
            ...options2.state
          },
          // Similarly, we'll maintain both our internal state and any user-provided
          // state.
          onStateChange: (updater) => {
            if (updater instanceof Function) {
              stateStore.update(updater);
            } else {
              stateStore.set(updater);
            }
            resolvedOptions.onStateChange == null || resolvedOptions.onStateChange(updater);
          }
        };
      });
      set(table);
    });
    return function stop() {
      unsubscribe();
    };
  });
  return tableReadable;
}
export {
  ColumnSizing,
  Expanding,
  Filters,
  Grouping,
  Headers,
  Ordering,
  Pagination,
  Pinning,
  RowSelection,
  Sorting,
  Visibility,
  aggregationFns,
  buildHeaderGroups,
  createCell,
  createColumn,
  createColumnHelper,
  createRow,
  createSvelteTable,
  createTable,
  defaultColumnSizing,
  expandRows,
  filterFns,
  flattenBy,
  flexRender,
  functionalUpdate,
  getCoreRowModel,
  getExpandedRowModel,
  getFacetedMinMaxValues,
  getFacetedRowModel,
  getFacetedUniqueValues,
  getFilteredRowModel,
  getGroupedRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  isFunction,
  isNumberArray,
  isRowSelected,
  isSubRowSelected,
  makeStateUpdater,
  memo,
  noop2 as noop,
  orderColumns,
  passiveEventSupported,
  reSplitAlphaNumeric,
  renderComponent,
  selectRowsFn,
  shouldAutoRemoveFilter,
  sortingFns
};
/*! Bundled license information:

@tanstack/svelte-table/build/lib/index.mjs:
  (**
   * svelte-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=@tanstack_svelte-table.js.map
