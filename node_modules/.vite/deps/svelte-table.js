import "./chunk-XML7UXAA.js";
import "./chunk-X7HCJ7ZS.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_text,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  set_data_dev,
  set_input_value,
  space,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-INSFP3VM.js";
import "./chunk-LYBY5SRM.js";
import "./chunk-34KZWS7D.js";

// node_modules/svelte-table/src/SvelteTable.svelte
var { Object: Object_1, console: console_1 } = globals;
var file = "node_modules/svelte-table/src/SvelteTable.svelte";
function add_css(target) {
  append_styles(target, "svelte-dsaf7t", "table.svelte-dsaf7t.svelte-dsaf7t{width:100%}.isSortable.svelte-dsaf7t.svelte-dsaf7t{cursor:pointer}.isClickable.svelte-dsaf7t.svelte-dsaf7t{cursor:pointer}tr.svelte-dsaf7t th select.svelte-dsaf7t{width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbHRlVGFibGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQSthRSxpQ0FBTSxDQUNKLEtBQUssQ0FBRSxJQUNULENBQ0EsdUNBQVksQ0FDVixNQUFNLENBQUUsT0FDVixDQUVBLHdDQUFhLENBQ1gsTUFBTSxDQUFFLE9BQ1YsQ0FFQSxnQkFBRSxDQUFDLEVBQUUsQ0FBQyxvQkFBTyxDQUNYLEtBQUssQ0FBRSxJQUNUIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlN2ZWx0ZVRhYmxlLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[56] = list[i];
  child_ctx[58] = i;
  return child_ctx;
}
var get_expanded_slot_changes = (dirty) => ({ row: dirty[0] & /*c_rows*/
8 });
var get_expanded_slot_context = (ctx) => ({ row: (
  /*row*/
  ctx[56]
), n: (
  /*n*/
  ctx[58]
) });
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[59] = list[i];
  child_ctx[61] = i;
  return child_ctx;
}
var get_row_slot_changes = (dirty) => ({ row: dirty[0] & /*c_rows*/
8 });
var get_row_slot_context = (ctx) => ({ row: (
  /*row*/
  ctx[56]
), n: (
  /*n*/
  ctx[58]
) });
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[59] = list[i];
  return child_ctx;
}
var get_header_slot_changes = (dirty) => ({
  sortOrder: dirty[0] & /*sortOrder*/
  2,
  sortBy: dirty[0] & /*sortBy*/
  1
});
var get_header_slot_context = (ctx) => ({
  sortOrder: (
    /*sortOrder*/
    ctx[1]
  ),
  sortBy: (
    /*sortBy*/
    ctx[0]
  )
});
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[59] = list[i];
  child_ctx[64] = list;
  child_ctx[65] = i;
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[66] = list[i];
  return child_ctx;
}
function create_if_block_7(ctx) {
  let tr;
  let t;
  let each_value_3 = ensure_array_like_dev(
    /*columns*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let if_block = (
    /*showExpandIcon*/
    ctx[11] && create_if_block_8(ctx)
  );
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      if (if_block)
        if_block.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "svelte-dsaf7t");
      add_location(tr, file, 304, 6, 8679);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
      if (if_block)
        if_block.m(tr, null);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*asStringArray, columns, classNameInput, filterSelections, classNameSelect, filterValues*/
      75595796) {
        each_value_3 = ensure_array_like_dev(
          /*columns*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
      if (
        /*showExpandIcon*/
        ctx2[11]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_8(ctx2);
          if_block.c();
          if_block.m(tr, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(304:4) {#if showFilterHeader}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let select;
  let option_1;
  let t_value = (
    /*col*/
    (ctx[59].filterPlaceholder || "") + ""
  );
  let t;
  let select_class_value;
  let mounted;
  let dispose;
  let each_value_4 = ensure_array_like_dev(
    /*filterValues*/
    ctx[23][
      /*col*/
      ctx[59].key
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  function select_change_handler() {
    ctx[44].call(
      select,
      /*col*/
      ctx[59]
    );
  }
  const block = {
    c: function create() {
      select = element("select");
      option_1 = element("option");
      t = text(t_value);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      select = claim_element(nodes, "SELECT", { class: true });
      var select_nodes = children(select);
      option_1 = claim_element(select_nodes, "OPTION", {});
      var option_1_nodes = children(option_1);
      t = claim_text(option_1_nodes, t_value);
      option_1_nodes.forEach(detach_dev);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option_1.__value = void 0;
      set_input_value(option_1, option_1.__value);
      add_location(option_1, file, 318, 16, 9297);
      attr_dev(select, "class", select_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameSelect*/
          ctx[15]
        )
      ) + " svelte-dsaf7t");
      if (
        /*filterSelections*/
        ctx[2][
          /*col*/
          ctx[59].key
        ] === void 0
      )
        add_render_callback(select_change_handler);
      add_location(select, file, 314, 14, 9147);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, select, anchor);
      append_hydration_dev(select, option_1);
      append_hydration_dev(option_1, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*filterSelections*/
        ctx[2][
          /*col*/
          ctx[59].key
        ],
        true
      );
      if (!mounted) {
        dispose = listen_dev(select, "change", select_change_handler);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*columns*/
      16 && t_value !== (t_value = /*col*/
      (ctx[59].filterPlaceholder || "") + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*filterValues, columns*/
      8388624) {
        each_value_4 = ensure_array_like_dev(
          /*filterValues*/
          ctx[23][
            /*col*/
            ctx[59].key
          ]
        );
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_4.length;
      }
      if (dirty[0] & /*classNameSelect*/
      32768 && select_class_value !== (select_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameSelect*/
          ctx[15]
        )
      ) + " svelte-dsaf7t")) {
        attr_dev(select, "class", select_class_value);
      }
      if (dirty[0] & /*filterSelections, columns, filterValues*/
      8388628) {
        select_option(
          select,
          /*filterSelections*/
          ctx[2][
            /*col*/
            ctx[59].key
          ]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(314:83) ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let input;
  let input_class_value;
  let input_placeholder_value;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[43].call(
      input,
      /*col*/
      ctx[59]
    );
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { class: true, placeholder: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", input_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameInput*/
          ctx[16]
        )
      ) + " svelte-dsaf7t");
      attr_dev(input, "placeholder", input_placeholder_value = /*col*/
      ctx[59].filterPlaceholder);
      add_location(input, file, 308, 14, 8864);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*filterSelections*/
        ctx[2][
          /*col*/
          ctx[59].key
        ]
      );
      if (!mounted) {
        dispose = listen_dev(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*classNameInput*/
      65536 && input_class_value !== (input_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameInput*/
          ctx[16]
        )
      ) + " svelte-dsaf7t")) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty[0] & /*columns, filterValues*/
      8388624 && input_placeholder_value !== (input_placeholder_value = /*col*/
      ctx[59].filterPlaceholder)) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty[0] & /*filterSelections, columns, filterValues*/
      8388628 && input.value !== /*filterSelections*/
      ctx[2][
        /*col*/
        ctx[59].key
      ]) {
        set_input_value(
          input,
          /*filterSelections*/
          ctx[2][
            /*col*/
            ctx[59].key
          ]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(308:12) {#if !col.hideFilterHeader && col.searchValue !== undefined}",
    ctx
  });
  return block;
}
function create_each_block_4(ctx) {
  let option_1;
  let t_value = (
    /*option*/
    ctx[66].name + ""
  );
  let t;
  let option_1_value_value;
  const block = {
    c: function create() {
      option_1 = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option_1 = claim_element(nodes, "OPTION", {});
      var option_1_nodes = children(option_1);
      t = claim_text(option_1_nodes, t_value);
      option_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option_1.__value = option_1_value_value = /*option*/
      ctx[66].value;
      set_input_value(option_1, option_1.__value);
      add_location(option_1, file, 320, 18, 9436);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option_1, anchor);
      append_hydration_dev(option_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*filterValues, columns*/
      8388624 && t_value !== (t_value = /*option*/
      ctx2[66].name + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*filterValues, columns*/
      8388624 && option_1_value_value !== (option_1_value_value = /*option*/
      ctx2[66].value)) {
        prop_dev(option_1, "__value", option_1_value_value);
        set_input_value(option_1, option_1.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(320:16) {#each filterValues[col.key] as option}",
    ctx
  });
  return block;
}
function create_each_block_3(ctx) {
  let th;
  let th_class_value;
  function select_block_type(ctx2, dirty) {
    if (!/*col*/
    ctx2[59].hideFilterHeader && /*col*/
    ctx2[59].searchValue !== void 0)
      return create_if_block_9;
    if (!/*col*/
    ctx2[59].hideFilterHeader && /*filterValues*/
    ctx2[23][
      /*col*/
      ctx2[59].key
    ] !== void 0)
      return create_if_block_10;
  }
  let current_block_type = select_block_type(ctx, [-1, -1, -1]);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      th = element("th");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      if (if_block)
        if_block.l(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", th_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26]([
          /*col*/
          ctx[59].headerFilterClass
        ])
      ) + " svelte-dsaf7t");
      add_location(th, file, 306, 10, 8725);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      if (if_block)
        if_block.m(th, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(th, null);
        }
      }
      if (dirty[0] & /*columns, filterValues*/
      8388624 && th_class_value !== (th_class_value = null_to_empty(
        /*asStringArray*/
        ctx2[26]([
          /*col*/
          ctx2[59].headerFilterClass
        ])
      ) + " svelte-dsaf7t")) {
        attr_dev(th, "class", th_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (if_block) {
        if_block.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(306:8) {#each columns as col}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let th;
  const block = {
    c: function create() {
      th = element("th");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {});
      children(th).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(th, file, 327, 10, 9625);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(327:8) {#if showExpandIcon}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*iconSortable*/
        ctx[8],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iconSortable*/
      256)
        html_tag.p(
          /*iconSortable*/
          ctx2[8]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(347:35) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let html_tag;
  let raw_value = (
    /*sortOrder*/
    (ctx[1] === 1 ? (
      /*iconAsc*/
      ctx[6]
    ) : (
      /*iconDesc*/
      ctx[7]
    )) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*sortOrder, iconAsc, iconDesc*/
      194 && raw_value !== (raw_value = /*sortOrder*/
      (ctx2[1] === 1 ? (
        /*iconAsc*/
        ctx2[6]
      ) : (
        /*iconDesc*/
        ctx2[7]
      )) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(345:12) {#if sortBy === col.key}",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let th;
  let t0_value = (
    /*col*/
    ctx[59].title + ""
  );
  let t0;
  let t1;
  let th_class_value;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*sortBy*/
      ctx2[0] === /*col*/
      ctx2[59].key
    )
      return create_if_block_5;
    if (
      /*col*/
      ctx2[59].sortable
    )
      return create_if_block_6;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1, -1]);
  let if_block = current_block_type && current_block_type(ctx);
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[45](
        /*col*/
        ctx[59],
        ...args
      )
    );
  }
  function keypress_handler(...args) {
    return (
      /*keypress_handler*/
      ctx[46](
        /*col*/
        ctx[59],
        ...args
      )
    );
  }
  const block = {
    c: function create() {
      th = element("th");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true, tabindex: true });
      var th_nodes = children(th);
      t0 = claim_text(th_nodes, t0_value);
      t1 = claim_space(th_nodes);
      if (if_block)
        if_block.l(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", th_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26]([
          /*col*/
          ctx[59].sortable ? "isSortable" : "",
          /*col*/
          ctx[59].headerClass
        ])
      ) + " svelte-dsaf7t");
      attr_dev(th, "tabindex", "0");
      add_location(th, file, 334, 10, 9766);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t0);
      append_hydration_dev(th, t1);
      if (if_block)
        if_block.m(th, null);
      if (!mounted) {
        dispose = [
          listen_dev(th, "click", click_handler, false, false, false, false),
          listen_dev(th, "keypress", keypress_handler, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*columns*/
      16 && t0_value !== (t0_value = /*col*/
      ctx[59].title + ""))
        set_data_dev(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(th, null);
        }
      }
      if (dirty[0] & /*columns, filterValues*/
      8388624 && th_class_value !== (th_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26]([
          /*col*/
          ctx[59].sortable ? "isSortable" : "",
          /*col*/
          ctx[59].headerClass
        ])
      ) + " svelte-dsaf7t")) {
        attr_dev(th, "class", th_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (if_block) {
        if_block.d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(334:8) {#each columns as col}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let th;
  const block = {
    c: function create() {
      th = element("th");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {});
      children(th).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(th, file, 352, 10, 10343);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(352:8) {#if showExpandIcon}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let tr;
  let t;
  let each_value_2 = ensure_array_like_dev(
    /*columns*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let if_block = (
    /*showExpandIcon*/
    ctx[11] && create_if_block_4(ctx)
  );
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      if (if_block)
        if_block.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file, 332, 6, 9720);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
      if (if_block)
        if_block.m(tr, null);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*asStringArray, columns, handleClickCol, sortOrder, iconAsc, iconDesc, sortBy, iconSortable*/
      201327059) {
        each_value_2 = ensure_array_like_dev(
          /*columns*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (
        /*showExpandIcon*/
        ctx2[11]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(tr, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(332:45)        ",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let t_value = (
    /*col*/
    (ctx[59].renderValue ? (
      /*col*/
      ctx[59].renderValue(
        /*row*/
        ctx[56],
        /*n*/
        ctx[58],
        /*colIndex*/
        ctx[61]
      )
    ) : (
      /*col*/
      ctx[59].value(
        /*row*/
        ctx[56],
        /*n*/
        ctx[58],
        /*colIndex*/
        ctx[61]
      )
    )) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*columns, c_rows*/
      24 && t_value !== (t_value = /*col*/
      (ctx2[59].renderValue ? (
        /*col*/
        ctx2[59].renderValue(
          /*row*/
          ctx2[56],
          /*n*/
          ctx2[58],
          /*colIndex*/
          ctx2[61]
        )
      ) : (
        /*col*/
        ctx2[59].value(
          /*row*/
          ctx2[56],
          /*n*/
          ctx2[58],
          /*colIndex*/
          ctx2[61]
        )
      )) + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(397:14) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let html_tag;
  let raw_value = (
    /*col*/
    (ctx[59].renderValue ? (
      /*col*/
      ctx[59].renderValue(
        /*row*/
        ctx[56],
        /*n*/
        ctx[58],
        /*colIndex*/
        ctx[61]
      )
    ) : (
      /*col*/
      ctx[59].value(
        /*row*/
        ctx[56],
        /*n*/
        ctx[58],
        /*colIndex*/
        ctx[61]
      )
    )) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*columns, c_rows*/
      24 && raw_value !== (raw_value = /*col*/
      (ctx2[59].renderValue ? (
        /*col*/
        ctx2[59].renderValue(
          /*row*/
          ctx2[56],
          /*n*/
          ctx2[58],
          /*colIndex*/
          ctx2[61]
        )
      ) : (
        /*col*/
        ctx2[59].value(
          /*row*/
          ctx2[56],
          /*n*/
          ctx2[58],
          /*colIndex*/
          ctx2[61]
        )
      )) + ""))
        html_tag.p(raw_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(393:38) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*col*/
    ctx[59].renderComponent.props || {},
    { row: (
      /*row*/
      ctx[56]
    ) },
    { col: (
      /*col*/
      ctx[59]
    ) }
  ];
  var switch_value = (
    /*col*/
    ctx[59].renderComponent.component || /*col*/
    ctx[59].renderComponent
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty[0] & /*columns, c_rows*/
    24) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*columns*/
        16 && get_spread_object(
          /*col*/
          ctx2[59].renderComponent.props || {}
        ),
        dirty[0] & /*c_rows*/
        8 && { row: (
          /*row*/
          ctx2[56]
        ) },
        dirty[0] & /*columns*/
        16 && { col: (
          /*col*/
          ctx2[59]
        ) }
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*columns*/
      16 && switch_value !== (switch_value = /*col*/
      ctx2[59].renderComponent.component || /*col*/
      ctx2[59].renderComponent)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*columns, c_rows*/
        24 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*columns*/
          16 && get_spread_object(
            /*col*/
            ctx2[59].renderComponent.props || {}
          ),
          dirty[0] & /*c_rows*/
          8 && { row: (
            /*row*/
            ctx2[56]
          ) },
          dirty[0] & /*columns*/
          16 && { col: (
            /*col*/
            ctx2[59]
          ) }
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(386:14) {#if col.renderComponent}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let td;
  let current_block_type_index;
  let if_block;
  let td_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_2, create_if_block_3, create_else_block];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*col*/
      ctx2[59].renderComponent
    )
      return 0;
    if (
      /*col*/
      ctx2[59].parseHTML
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function click_handler_1(...args) {
    return (
      /*click_handler_1*/
      ctx[47](
        /*row*/
        ctx[56],
        /*col*/
        ctx[59],
        ...args
      )
    );
  }
  function keypress_handler_1(...args) {
    return (
      /*keypress_handler_1*/
      ctx[48](
        /*row*/
        ctx[56],
        /*col*/
        ctx[59],
        ...args
      )
    );
  }
  const block = {
    c: function create() {
      td = element("td");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      if_block.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", td_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26]([
          typeof /*col*/
          ctx[59].class === "string" ? (
            /*col*/
            ctx[59].class
          ) : null,
          typeof /*col*/
          ctx[59].class === "function" ? (
            /*col*/
            ctx[59].class(
              /*row*/
              ctx[56],
              /*n*/
              ctx[58],
              /*colIndex*/
              ctx[61]
            )
          ) : null,
          /*classNameCell*/
          ctx[18]
        ])
      ) + " svelte-dsaf7t");
      add_location(td, file, 373, 12, 11053);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if_blocks[current_block_type_index].m(td, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(td, "click", click_handler_1, false, false, false, false),
          listen_dev(td, "keypress", keypress_handler_1, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(td, null);
      }
      if (!current || dirty[0] & /*columns, c_rows, classNameCell, filterValues*/
      8650776 && td_class_value !== (td_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26]([
          typeof /*col*/
          ctx[59].class === "string" ? (
            /*col*/
            ctx[59].class
          ) : null,
          typeof /*col*/
          ctx[59].class === "function" ? (
            /*col*/
            ctx[59].class(
              /*row*/
              ctx[56],
              /*n*/
              ctx[58],
              /*colIndex*/
              ctx[61]
            )
          ) : null,
          /*classNameCell*/
          ctx[18]
        ])
      ) + " svelte-dsaf7t")) {
        attr_dev(td, "class", td_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(373:10) {#each columns as col, colIndex}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let td;
  let span;
  let html_tag;
  let raw_value = (
    /*row*/
    (ctx[56].$expanded ? (
      /*iconExpand*/
      ctx[9]
    ) : (
      /*iconExpanded*/
      ctx[10]
    )) + ""
  );
  let td_class_value;
  let mounted;
  let dispose;
  function click_handler_2(...args) {
    return (
      /*click_handler_2*/
      ctx[49](
        /*row*/
        ctx[56],
        ...args
      )
    );
  }
  function keypress_handler_2(...args) {
    return (
      /*keypress_handler_2*/
      ctx[50](
        /*row*/
        ctx[56],
        ...args
      )
    );
  }
  const block = {
    c: function create() {
      td = element("td");
      span = element("span");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      span = claim_element(td_nodes, "SPAN", { class: true, tabindex: true, role: true });
      var span_nodes = children(span);
      html_tag = claim_html_tag(span_nodes, false);
      span_nodes.forEach(detach_dev);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(span, "class", "isClickable svelte-dsaf7t");
      attr_dev(span, "tabindex", "0");
      attr_dev(span, "role", "button");
      add_location(span, file, 405, 14, 12285);
      attr_dev(td, "class", td_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameCellExpand*/
          ctx[22]
        )
      ) + " svelte-dsaf7t");
      add_location(td, file, 404, 12, 12223);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, span);
      html_tag.m(raw_value, span);
      if (!mounted) {
        dispose = [
          listen_dev(span, "click", click_handler_2, false, false, false, false),
          listen_dev(span, "keypress", keypress_handler_2, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*c_rows, iconExpand, iconExpanded*/
      1544 && raw_value !== (raw_value = /*row*/
      (ctx[56].$expanded ? (
        /*iconExpand*/
        ctx[9]
      ) : (
        /*iconExpanded*/
        ctx[10]
      )) + ""))
        html_tag.p(raw_value);
      if (dirty[0] & /*classNameCellExpand*/
      4194304 && td_class_value !== (td_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameCellExpand*/
          ctx[22]
        )
      ) + " svelte-dsaf7t")) {
        attr_dev(td, "class", td_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(404:10) {#if showExpandIcon}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let tr;
  let td;
  let tr_class_value;
  let current;
  const expanded_slot_template = (
    /*#slots*/
    ctx[42].expanded
  );
  const expanded_slot = create_slot(
    expanded_slot_template,
    ctx,
    /*$$scope*/
    ctx[41],
    get_expanded_slot_context
  );
  const block = {
    c: function create() {
      tr = element("tr");
      td = element("td");
      if (expanded_slot)
        expanded_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      td = claim_element(tr_nodes, "TD", { colspan: true });
      var td_nodes = children(td);
      if (expanded_slot)
        expanded_slot.l(td_nodes);
      td_nodes.forEach(detach_dev);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        td,
        "colspan",
        /*colspan*/
        ctx[24]
      );
      add_location(td, file, 420, 13, 12799);
      attr_dev(tr, "class", tr_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameExpandedContent*/
          ctx[21]
        )
      ) + " svelte-dsaf7t");
      add_location(tr, file, 419, 10, 12734);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, td);
      if (expanded_slot) {
        expanded_slot.m(td, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (expanded_slot) {
        if (expanded_slot.p && (!current || dirty[0] & /*c_rows*/
        8 | dirty[1] & /*$$scope*/
        1024)) {
          update_slot_base(
            expanded_slot,
            expanded_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[41],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[41]
            ) : get_slot_changes(
              expanded_slot_template,
              /*$$scope*/
              ctx2[41],
              dirty,
              get_expanded_slot_changes
            ),
            get_expanded_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*colspan*/
      16777216) {
        attr_dev(
          td,
          "colspan",
          /*colspan*/
          ctx2[24]
        );
      }
      if (!current || dirty[0] & /*classNameExpandedContent*/
      2097152 && tr_class_value !== (tr_class_value = null_to_empty(
        /*asStringArray*/
        ctx2[26](
          /*classNameExpandedContent*/
          ctx2[21]
        )
      ) + " svelte-dsaf7t")) {
        attr_dev(tr, "class", tr_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(expanded_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(expanded_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      if (expanded_slot)
        expanded_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(419:8) {#if row.$expanded}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let tr;
  let t0;
  let tr_class_value;
  let tr_tabindex_value;
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like_dev(
    /*columns*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block0 = (
    /*showExpandIcon*/
    ctx[11] && create_if_block_1(ctx)
  );
  function click_handler_3(...args) {
    return (
      /*click_handler_3*/
      ctx[51](
        /*row*/
        ctx[56],
        ...args
      )
    );
  }
  function keypress_handler_3(...args) {
    return (
      /*keypress_handler_3*/
      ctx[52](
        /*row*/
        ctx[56],
        ...args
      )
    );
  }
  let if_block1 = (
    /*row*/
    ctx[56].$expanded && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true, tabindex: true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t0 = claim_space(tr_nodes);
      if (if_block0)
        if_block0.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", tr_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26]([
          typeof /*classNameRow*/
          ctx[17] === "string" ? (
            /*classNameRow*/
            ctx[17]
          ) : null,
          typeof /*classNameRow*/
          ctx[17] === "function" ? (
            /*classNameRow*/
            ctx[17](
              /*row*/
              ctx[56],
              /*n*/
              ctx[58]
            )
          ) : null,
          /*row*/
          ctx[56].$expanded && /*classNameRowExpanded*/
          ctx[20],
          /*row*/
          ctx[56].$selected && /*classNameRowSelected*/
          ctx[19]
        ])
      ) + " svelte-dsaf7t");
      attr_dev(tr, "tabindex", tr_tabindex_value = /*selectOnClick*/
      ctx[5] ? "0" : null);
      add_location(tr, file, 361, 8, 10519);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t0);
      if (if_block0)
        if_block0.m(tr, null);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(tr, "click", click_handler_3, false, false, false, false),
          listen_dev(tr, "keypress", keypress_handler_3, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*asStringArray, columns, c_rows, classNameCell, handleClickCell*/
      1141112856) {
        each_value_1 = ensure_array_like_dev(
          /*columns*/
          ctx[4]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tr, t0);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*showExpandIcon*/
        ctx[11]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_1(ctx);
          if_block0.c();
          if_block0.m(tr, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty[0] & /*classNameRow, c_rows, classNameRowExpanded, classNameRowSelected*/
      1703944 && tr_class_value !== (tr_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26]([
          typeof /*classNameRow*/
          ctx[17] === "string" ? (
            /*classNameRow*/
            ctx[17]
          ) : null,
          typeof /*classNameRow*/
          ctx[17] === "function" ? (
            /*classNameRow*/
            ctx[17](
              /*row*/
              ctx[56],
              /*n*/
              ctx[58]
            )
          ) : null,
          /*row*/
          ctx[56].$expanded && /*classNameRowExpanded*/
          ctx[20],
          /*row*/
          ctx[56].$selected && /*classNameRowSelected*/
          ctx[19]
        ])
      ) + " svelte-dsaf7t")) {
        attr_dev(tr, "class", tr_class_value);
      }
      if (!current || dirty[0] & /*selectOnClick*/
      32 && tr_tabindex_value !== (tr_tabindex_value = /*selectOnClick*/
      ctx[5] ? "0" : null)) {
        attr_dev(tr, "tabindex", tr_tabindex_value);
      }
      if (
        /*row*/
        ctx[56].$expanded
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty[0] & /*c_rows*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_each(each_blocks, detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(361:33)          ",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let current;
  const row_slot_template = (
    /*#slots*/
    ctx[42].row
  );
  const row_slot = create_slot(
    row_slot_template,
    ctx,
    /*$$scope*/
    ctx[41],
    get_row_slot_context
  );
  const row_slot_or_fallback = row_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (row_slot_or_fallback)
        row_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (row_slot_or_fallback)
        row_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (row_slot_or_fallback) {
        row_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (row_slot) {
        if (row_slot.p && (!current || dirty[0] & /*c_rows*/
        8 | dirty[1] & /*$$scope*/
        1024)) {
          update_slot_base(
            row_slot,
            row_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[41],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[41]
            ) : get_slot_changes(
              row_slot_template,
              /*$$scope*/
              ctx2[41],
              dirty,
              get_row_slot_changes
            ),
            get_row_slot_context
          );
        }
      } else {
        if (row_slot_or_fallback && row_slot_or_fallback.p && (!current || dirty[0] & /*classNameExpandedContent, colspan, c_rows, classNameRow, classNameRowExpanded, classNameRowSelected, selectOnClick, classNameCellExpand, iconExpand, iconExpanded, showExpandIcon, columns, classNameCell*/
        25038392 | dirty[1] & /*$$scope*/
        1024)) {
          row_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(row_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(row_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (row_slot_or_fallback)
        row_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(360:4) {#each c_rows as row, n}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let table;
  let thead;
  let t0;
  let thead_class_value;
  let t1;
  let tbody;
  let tbody_class_value;
  let table_class_value;
  let current;
  let if_block = (
    /*showFilterHeader*/
    ctx[25] && create_if_block_7(ctx)
  );
  const header_slot_template = (
    /*#slots*/
    ctx[42].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[41],
    get_header_slot_context
  );
  const header_slot_or_fallback = header_slot || fallback_block_1(ctx);
  let each_value = ensure_array_like_dev(
    /*c_rows*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      table = element("table");
      thead = element("thead");
      if (if_block)
        if_block.c();
      t0 = space();
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
      t1 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      if (if_block)
        if_block.l(thead_nodes);
      t0 = claim_space(thead_nodes);
      if (header_slot_or_fallback)
        header_slot_or_fallback.l(thead_nodes);
      thead_nodes.forEach(detach_dev);
      t1 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(thead, "class", thead_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameThead*/
          ctx[13]
        )
      ) + " svelte-dsaf7t");
      add_location(thead, file, 302, 2, 8600);
      attr_dev(tbody, "class", tbody_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameTbody*/
          ctx[14]
        )
      ) + " svelte-dsaf7t");
      add_location(tbody, file, 358, 2, 10402);
      attr_dev(table, "class", table_class_value = null_to_empty(
        /*asStringArray*/
        ctx[26](
          /*classNameTable*/
          ctx[12]
        )
      ) + " svelte-dsaf7t");
      add_location(table, file, 301, 0, 8552);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      append_hydration_dev(table, thead);
      if (if_block)
        if_block.m(thead, null);
      append_hydration_dev(thead, t0);
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(thead, null);
      }
      append_hydration_dev(table, t1);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*showFilterHeader*/
        ctx2[25]
      )
        if_block.p(ctx2, dirty);
      if (header_slot) {
        if (header_slot.p && (!current || dirty[0] & /*sortOrder, sortBy*/
        3 | dirty[1] & /*$$scope*/
        1024)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[41],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[41]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[41],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty[0] & /*showExpandIcon, columns, sortOrder, iconAsc, iconDesc, sortBy, iconSortable*/
        2515)) {
          header_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*classNameThead*/
      8192 && thead_class_value !== (thead_class_value = null_to_empty(
        /*asStringArray*/
        ctx2[26](
          /*classNameThead*/
          ctx2[13]
        )
      ) + " svelte-dsaf7t")) {
        attr_dev(thead, "class", thead_class_value);
      }
      if (dirty[0] & /*asStringArray, classNameExpandedContent, colspan, c_rows, classNameRow, classNameRowExpanded, classNameRowSelected, selectOnClick, handleClickRow, classNameCellExpand, handleClickExpand, iconExpand, iconExpanded, showExpandIcon, columns, classNameCell, handleClickCell*/
      1971195448 | dirty[1] & /*$$scope*/
      1024) {
        each_value = ensure_array_like_dev(
          /*c_rows*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tbody, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*classNameTbody*/
      16384 && tbody_class_value !== (tbody_class_value = null_to_empty(
        /*asStringArray*/
        ctx2[26](
          /*classNameTbody*/
          ctx2[14]
        )
      ) + " svelte-dsaf7t")) {
        attr_dev(tbody, "class", tbody_class_value);
      }
      if (!current || dirty[0] & /*classNameTable*/
      4096 && table_class_value !== (table_class_value = null_to_empty(
        /*asStringArray*/
        ctx2[26](
          /*classNameTable*/
          ctx2[12]
        )
      ) + " svelte-dsaf7t")) {
        attr_dev(table, "class", table_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot_or_fallback, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(table);
      }
      if (if_block)
        if_block.d();
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let colspan;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteTable", slots, ["header", "expanded", "row"]);
  let { columns } = $$props;
  let { rows } = $$props;
  let { c_rows = void 0 } = $$props;
  let { sortOrders = [1, -1] } = $$props;
  let { sortBy = "" } = $$props;
  let { sortOrder = (sortOrders == null ? void 0 : sortOrders[0]) || 1 } = $$props;
  let { filterSelections = {} } = $$props;
  let { expanded = [] } = $$props;
  let { selected = [] } = $$props;
  let { expandRowKey = null } = $$props;
  let { rowKey = expandRowKey } = $$props;
  let { expandSingle = false } = $$props;
  let { selectSingle = false } = $$props;
  let { selectOnClick = false } = $$props;
  let { iconAsc = "▲" } = $$props;
  let { iconDesc = "▼" } = $$props;
  let { iconSortable = "" } = $$props;
  let { iconExpand = "▼" } = $$props;
  let { iconExpanded = "▲" } = $$props;
  let { showExpandIcon = false } = $$props;
  let { classNameTable = "" } = $$props;
  let { classNameThead = "" } = $$props;
  let { classNameTbody = "" } = $$props;
  let { classNameSelect = "" } = $$props;
  let { classNameInput = "" } = $$props;
  let { classNameRow = null } = $$props;
  let { classNameCell = "" } = $$props;
  let { classNameRowSelected = null } = $$props;
  let { classNameRowExpanded = null } = $$props;
  let { classNameExpandedContent = "" } = $$props;
  let { classNameCellExpand = "" } = $$props;
  const dispatch = createEventDispatcher();
  let sortFunction = () => "";
  if (!Array.isArray(expanded))
    throw "'expanded' needs to be an array";
  if (!Array.isArray(selected))
    throw "'selection' needs to be an array";
  if (expandRowKey !== null) {
    console.warn("'expandRowKey' is deprecated in favour of 'rowKey'");
  }
  if (classNameRowSelected && !rowKey) {
    console.error("'rowKey' is needed to use 'classNameRowSelected'");
  }
  let showFilterHeader = columns.some((c) => {
    return !c.hideFilterHeader && (c.filterOptions !== void 0 || c.searchValue !== void 0);
  });
  let filterValues = {};
  let columnByKey;
  const asStringArray = (v) => [].concat(v).filter((v2) => v2 !== null && typeof v2 === "string" && v2 !== "").join(" ");
  const calculateFilterValues = () => {
    $$invalidate(23, filterValues = {});
    columns.forEach((c) => {
      if (typeof c.filterOptions === "function") {
        $$invalidate(23, filterValues[c.key] = c.filterOptions(rows), filterValues);
      } else if (Array.isArray(c.filterOptions)) {
        $$invalidate(23, filterValues[c.key] = c.filterOptions.map((val) => ({ name: val, value: val })), filterValues);
      }
    });
  };
  const updateSortOrder = (colKey) => {
    return colKey === sortBy ? sortOrders[(sortOrders.findIndex((o) => o === sortOrder) + 1) % sortOrders.length] : sortOrders[0];
  };
  const handleClickCol = (event, col) => {
    if (col.sortable) {
      $$invalidate(1, sortOrder = updateSortOrder(col.key));
      $$invalidate(0, sortBy = sortOrder ? col.key : void 0);
    }
    dispatch("clickCol", { event, col, key: col.key });
  };
  const handleClickRow = (event, row) => {
    if (selectOnClick) {
      if (selectSingle) {
        if (selected.includes(row[rowKey])) {
          $$invalidate(32, selected = []);
        } else {
          $$invalidate(32, selected = [row[rowKey]]);
        }
      } else {
        if (selected.includes(row[rowKey])) {
          $$invalidate(32, selected = selected.filter((r) => r != row[rowKey]));
        } else {
          $$invalidate(32, selected = [...selected, row[rowKey]].sort());
        }
      }
    }
    dispatch("clickRow", { event, row });
  };
  const handleClickExpand = (event, row) => {
    row.$expanded = !row.$expanded;
    const keyVal = row[rowKey];
    if (expandSingle && row.$expanded) {
      $$invalidate(31, expanded = [keyVal]);
    } else if (expandSingle) {
      $$invalidate(31, expanded = []);
    } else if (!row.$expanded) {
      $$invalidate(31, expanded = expanded.filter((r) => r != keyVal));
    } else {
      $$invalidate(31, expanded = [...expanded, keyVal]);
    }
    dispatch("clickExpand", { event, row });
  };
  const handleClickCell = (event, row, key) => {
    dispatch("clickCell", { event, row, key });
  };
  $$self.$$.on_mount.push(function() {
    if (columns === void 0 && !("columns" in $$props || $$self.$$.bound[$$self.$$.props["columns"]])) {
      console_1.warn("<SvelteTable> was created without expected prop 'columns'");
    }
    if (rows === void 0 && !("rows" in $$props || $$self.$$.bound[$$self.$$.props["rows"]])) {
      console_1.warn("<SvelteTable> was created without expected prop 'rows'");
    }
  });
  const writable_props = [
    "columns",
    "rows",
    "c_rows",
    "sortOrders",
    "sortBy",
    "sortOrder",
    "filterSelections",
    "expanded",
    "selected",
    "expandRowKey",
    "rowKey",
    "expandSingle",
    "selectSingle",
    "selectOnClick",
    "iconAsc",
    "iconDesc",
    "iconSortable",
    "iconExpand",
    "iconExpanded",
    "showExpandIcon",
    "classNameTable",
    "classNameThead",
    "classNameTbody",
    "classNameSelect",
    "classNameInput",
    "classNameRow",
    "classNameCell",
    "classNameRowSelected",
    "classNameRowExpanded",
    "classNameExpandedContent",
    "classNameCellExpand"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<SvelteTable> was created with unknown prop '${key}'`);
  });
  function input_input_handler(col) {
    filterSelections[col.key] = this.value;
    $$invalidate(2, filterSelections);
    $$invalidate(23, filterValues);
    $$invalidate(4, columns);
  }
  function select_change_handler(col) {
    filterSelections[col.key] = select_value(this);
    $$invalidate(2, filterSelections);
    $$invalidate(23, filterValues);
    $$invalidate(4, columns);
  }
  const click_handler = (col, e) => handleClickCol(e, col);
  const keypress_handler = (col, e) => e.key === "Enter" && handleClickCol(e, col);
  const click_handler_1 = (row, col, e) => handleClickCell(e, row, col.key);
  const keypress_handler_1 = (row, col, e) => e.key === "Enter" && handleClickCell(e, row, col.key);
  const click_handler_2 = (row, e) => handleClickExpand(e, row);
  const keypress_handler_2 = (row, e) => e.key === "Enter" && handleClickExpand(e, row);
  const click_handler_3 = (row, e) => handleClickRow(e, row);
  const keypress_handler_3 = (row, e) => e.key === "Enter" && handleClickRow(e, row);
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(4, columns = $$props2.columns);
    if ("rows" in $$props2)
      $$invalidate(33, rows = $$props2.rows);
    if ("c_rows" in $$props2)
      $$invalidate(3, c_rows = $$props2.c_rows);
    if ("sortOrders" in $$props2)
      $$invalidate(34, sortOrders = $$props2.sortOrders);
    if ("sortBy" in $$props2)
      $$invalidate(0, sortBy = $$props2.sortBy);
    if ("sortOrder" in $$props2)
      $$invalidate(1, sortOrder = $$props2.sortOrder);
    if ("filterSelections" in $$props2)
      $$invalidate(2, filterSelections = $$props2.filterSelections);
    if ("expanded" in $$props2)
      $$invalidate(31, expanded = $$props2.expanded);
    if ("selected" in $$props2)
      $$invalidate(32, selected = $$props2.selected);
    if ("expandRowKey" in $$props2)
      $$invalidate(35, expandRowKey = $$props2.expandRowKey);
    if ("rowKey" in $$props2)
      $$invalidate(36, rowKey = $$props2.rowKey);
    if ("expandSingle" in $$props2)
      $$invalidate(37, expandSingle = $$props2.expandSingle);
    if ("selectSingle" in $$props2)
      $$invalidate(38, selectSingle = $$props2.selectSingle);
    if ("selectOnClick" in $$props2)
      $$invalidate(5, selectOnClick = $$props2.selectOnClick);
    if ("iconAsc" in $$props2)
      $$invalidate(6, iconAsc = $$props2.iconAsc);
    if ("iconDesc" in $$props2)
      $$invalidate(7, iconDesc = $$props2.iconDesc);
    if ("iconSortable" in $$props2)
      $$invalidate(8, iconSortable = $$props2.iconSortable);
    if ("iconExpand" in $$props2)
      $$invalidate(9, iconExpand = $$props2.iconExpand);
    if ("iconExpanded" in $$props2)
      $$invalidate(10, iconExpanded = $$props2.iconExpanded);
    if ("showExpandIcon" in $$props2)
      $$invalidate(11, showExpandIcon = $$props2.showExpandIcon);
    if ("classNameTable" in $$props2)
      $$invalidate(12, classNameTable = $$props2.classNameTable);
    if ("classNameThead" in $$props2)
      $$invalidate(13, classNameThead = $$props2.classNameThead);
    if ("classNameTbody" in $$props2)
      $$invalidate(14, classNameTbody = $$props2.classNameTbody);
    if ("classNameSelect" in $$props2)
      $$invalidate(15, classNameSelect = $$props2.classNameSelect);
    if ("classNameInput" in $$props2)
      $$invalidate(16, classNameInput = $$props2.classNameInput);
    if ("classNameRow" in $$props2)
      $$invalidate(17, classNameRow = $$props2.classNameRow);
    if ("classNameCell" in $$props2)
      $$invalidate(18, classNameCell = $$props2.classNameCell);
    if ("classNameRowSelected" in $$props2)
      $$invalidate(19, classNameRowSelected = $$props2.classNameRowSelected);
    if ("classNameRowExpanded" in $$props2)
      $$invalidate(20, classNameRowExpanded = $$props2.classNameRowExpanded);
    if ("classNameExpandedContent" in $$props2)
      $$invalidate(21, classNameExpandedContent = $$props2.classNameExpandedContent);
    if ("classNameCellExpand" in $$props2)
      $$invalidate(22, classNameCellExpand = $$props2.classNameCellExpand);
    if ("$$scope" in $$props2)
      $$invalidate(41, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    columns,
    rows,
    c_rows,
    sortOrders,
    sortBy,
    sortOrder,
    filterSelections,
    expanded,
    selected,
    expandRowKey,
    rowKey,
    expandSingle,
    selectSingle,
    selectOnClick,
    iconAsc,
    iconDesc,
    iconSortable,
    iconExpand,
    iconExpanded,
    showExpandIcon,
    classNameTable,
    classNameThead,
    classNameTbody,
    classNameSelect,
    classNameInput,
    classNameRow,
    classNameCell,
    classNameRowSelected,
    classNameRowExpanded,
    classNameExpandedContent,
    classNameCellExpand,
    dispatch,
    sortFunction,
    showFilterHeader,
    filterValues,
    columnByKey,
    asStringArray,
    calculateFilterValues,
    updateSortOrder,
    handleClickCol,
    handleClickRow,
    handleClickExpand,
    handleClickCell,
    colspan
  });
  $$self.$inject_state = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(4, columns = $$props2.columns);
    if ("rows" in $$props2)
      $$invalidate(33, rows = $$props2.rows);
    if ("c_rows" in $$props2)
      $$invalidate(3, c_rows = $$props2.c_rows);
    if ("sortOrders" in $$props2)
      $$invalidate(34, sortOrders = $$props2.sortOrders);
    if ("sortBy" in $$props2)
      $$invalidate(0, sortBy = $$props2.sortBy);
    if ("sortOrder" in $$props2)
      $$invalidate(1, sortOrder = $$props2.sortOrder);
    if ("filterSelections" in $$props2)
      $$invalidate(2, filterSelections = $$props2.filterSelections);
    if ("expanded" in $$props2)
      $$invalidate(31, expanded = $$props2.expanded);
    if ("selected" in $$props2)
      $$invalidate(32, selected = $$props2.selected);
    if ("expandRowKey" in $$props2)
      $$invalidate(35, expandRowKey = $$props2.expandRowKey);
    if ("rowKey" in $$props2)
      $$invalidate(36, rowKey = $$props2.rowKey);
    if ("expandSingle" in $$props2)
      $$invalidate(37, expandSingle = $$props2.expandSingle);
    if ("selectSingle" in $$props2)
      $$invalidate(38, selectSingle = $$props2.selectSingle);
    if ("selectOnClick" in $$props2)
      $$invalidate(5, selectOnClick = $$props2.selectOnClick);
    if ("iconAsc" in $$props2)
      $$invalidate(6, iconAsc = $$props2.iconAsc);
    if ("iconDesc" in $$props2)
      $$invalidate(7, iconDesc = $$props2.iconDesc);
    if ("iconSortable" in $$props2)
      $$invalidate(8, iconSortable = $$props2.iconSortable);
    if ("iconExpand" in $$props2)
      $$invalidate(9, iconExpand = $$props2.iconExpand);
    if ("iconExpanded" in $$props2)
      $$invalidate(10, iconExpanded = $$props2.iconExpanded);
    if ("showExpandIcon" in $$props2)
      $$invalidate(11, showExpandIcon = $$props2.showExpandIcon);
    if ("classNameTable" in $$props2)
      $$invalidate(12, classNameTable = $$props2.classNameTable);
    if ("classNameThead" in $$props2)
      $$invalidate(13, classNameThead = $$props2.classNameThead);
    if ("classNameTbody" in $$props2)
      $$invalidate(14, classNameTbody = $$props2.classNameTbody);
    if ("classNameSelect" in $$props2)
      $$invalidate(15, classNameSelect = $$props2.classNameSelect);
    if ("classNameInput" in $$props2)
      $$invalidate(16, classNameInput = $$props2.classNameInput);
    if ("classNameRow" in $$props2)
      $$invalidate(17, classNameRow = $$props2.classNameRow);
    if ("classNameCell" in $$props2)
      $$invalidate(18, classNameCell = $$props2.classNameCell);
    if ("classNameRowSelected" in $$props2)
      $$invalidate(19, classNameRowSelected = $$props2.classNameRowSelected);
    if ("classNameRowExpanded" in $$props2)
      $$invalidate(20, classNameRowExpanded = $$props2.classNameRowExpanded);
    if ("classNameExpandedContent" in $$props2)
      $$invalidate(21, classNameExpandedContent = $$props2.classNameExpandedContent);
    if ("classNameCellExpand" in $$props2)
      $$invalidate(22, classNameCellExpand = $$props2.classNameCellExpand);
    if ("sortFunction" in $$props2)
      $$invalidate(39, sortFunction = $$props2.sortFunction);
    if ("showFilterHeader" in $$props2)
      $$invalidate(25, showFilterHeader = $$props2.showFilterHeader);
    if ("filterValues" in $$props2)
      $$invalidate(23, filterValues = $$props2.filterValues);
    if ("columnByKey" in $$props2)
      $$invalidate(40, columnByKey = $$props2.columnByKey);
    if ("colspan" in $$props2)
      $$invalidate(24, colspan = $$props2.colspan);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*columns*/
    16) {
      $: {
        $$invalidate(40, columnByKey = {});
        columns.forEach((col) => {
          $$invalidate(40, columnByKey[col.key] = col, columnByKey);
        });
      }
    }
    if ($$self.$$.dirty[0] & /*showExpandIcon, columns*/
    2064) {
      $:
        $$invalidate(24, colspan = (showExpandIcon ? 1 : 0) + columns.length);
    }
    if ($$self.$$.dirty[0] & /*sortBy*/
    1 | $$self.$$.dirty[1] & /*columnByKey*/
    512) {
      $: {
        let col = columnByKey[sortBy];
        if (col !== void 0 && col.sortable === true && typeof col.value === "function") {
          $$invalidate(39, sortFunction = (r) => col.value(r));
        }
      }
    }
    if ($$self.$$.dirty[0] & /*filterSelections, sortBy, sortOrder*/
    7 | $$self.$$.dirty[1] & /*rows, columnByKey, sortFunction, rowKey, expanded, selected*/
    807) {
      $:
        $$invalidate(3, c_rows = rows.filter((r) => {
          return Object.keys(filterSelections).every((f) => {
            var _a;
            let resSearch = null;
            if (columnByKey[f] === void 0) {
              return true;
            } else if (!((_a = columnByKey[f]) == null ? void 0 : _a.searchValue)) {
              resSearch = false;
            } else if (filterSelections[f] === "") {
              return true;
            } else if (columnByKey[f].searchValue.length === 1) {
              resSearch = (columnByKey[f].searchValue(r) + "").toLocaleLowerCase().indexOf((filterSelections[f] + "").toLocaleLowerCase()) >= 0;
            } else if (columnByKey[f].searchValue.length === 2) {
              resSearch = !!columnByKey[f].searchValue(r, filterSelections[f] + "");
            }
            let resFilter = resSearch || filterSelections[f] === void 0 || // default to value() if filterValue() not provided in col
            filterSelections[f] === (typeof columnByKey[f].filterValue === "function" ? columnByKey[f].filterValue(r) : columnByKey[f].value(r));
            return resFilter;
          });
        }).map((r) => Object.assign({}, r, {
          // internal row property for sort order
          $sortOn: sortFunction(r),
          // internal row property for expanded rows
          $expanded: rowKey !== null && expanded.indexOf(r[rowKey]) >= 0,
          $selected: rowKey !== null && selected.indexOf(r[rowKey]) >= 0
        })).sort((a, b) => {
          if (!sortBy)
            return 0;
          else if (a.$sortOn > b.$sortOn)
            return sortOrder;
          else if (a.$sortOn < b.$sortOn)
            return -sortOrder;
          return 0;
        }));
    }
    if ($$self.$$.dirty[0] & /*columns*/
    16 | $$self.$$.dirty[1] & /*rows*/
    4) {
      $: {
        if (showFilterHeader && columns && rows) {
          calculateFilterValues();
        }
      }
    }
  };
  return [
    sortBy,
    sortOrder,
    filterSelections,
    c_rows,
    columns,
    selectOnClick,
    iconAsc,
    iconDesc,
    iconSortable,
    iconExpand,
    iconExpanded,
    showExpandIcon,
    classNameTable,
    classNameThead,
    classNameTbody,
    classNameSelect,
    classNameInput,
    classNameRow,
    classNameCell,
    classNameRowSelected,
    classNameRowExpanded,
    classNameExpandedContent,
    classNameCellExpand,
    filterValues,
    colspan,
    showFilterHeader,
    asStringArray,
    handleClickCol,
    handleClickRow,
    handleClickExpand,
    handleClickCell,
    expanded,
    selected,
    rows,
    sortOrders,
    expandRowKey,
    rowKey,
    expandSingle,
    selectSingle,
    sortFunction,
    columnByKey,
    $$scope,
    slots,
    input_input_handler,
    select_change_handler,
    click_handler,
    keypress_handler,
    click_handler_1,
    keypress_handler_1,
    click_handler_2,
    keypress_handler_2,
    click_handler_3,
    keypress_handler_3
  ];
}
var SvelteTable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        columns: 4,
        rows: 33,
        c_rows: 3,
        sortOrders: 34,
        sortBy: 0,
        sortOrder: 1,
        filterSelections: 2,
        expanded: 31,
        selected: 32,
        expandRowKey: 35,
        rowKey: 36,
        expandSingle: 37,
        selectSingle: 38,
        selectOnClick: 5,
        iconAsc: 6,
        iconDesc: 7,
        iconSortable: 8,
        iconExpand: 9,
        iconExpanded: 10,
        showExpandIcon: 11,
        classNameTable: 12,
        classNameThead: 13,
        classNameTbody: 14,
        classNameSelect: 15,
        classNameInput: 16,
        classNameRow: 17,
        classNameCell: 18,
        classNameRowSelected: 19,
        classNameRowExpanded: 20,
        classNameExpandedContent: 21,
        classNameCellExpand: 22
      },
      add_css,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteTable",
      options,
      id: create_fragment.name
    });
  }
  get columns() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get c_rows() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set c_rows(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortOrders() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortOrders(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortBy() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortBy(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortOrder() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortOrder(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterSelections() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterSelections(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expanded() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandRowKey() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandRowKey(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowKey() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowKey(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandSingle() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandSingle(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectSingle() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectSingle(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectOnClick() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectOnClick(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconAsc() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconAsc(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconDesc() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconDesc(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconSortable() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconSortable(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconExpand() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconExpand(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconExpanded() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconExpanded(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showExpandIcon() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showExpandIcon(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameTable() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameTable(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameThead() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameThead(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameTbody() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameTbody(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameSelect() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameSelect(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameInput() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameInput(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameRow() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameRow(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameCell() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameCell(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameRowSelected() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameRowSelected(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameRowExpanded() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameRowExpanded(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameExpandedContent() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameExpandedContent(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get classNameCellExpand() {
    throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set classNameCellExpand(value) {
    throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteTable_default = SvelteTable;
export {
  SvelteTable_default as default
};
//# sourceMappingURL=svelte-table.js.map
